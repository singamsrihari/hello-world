"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Emitter = void 0;
var _assert = require("assert");
var leap = require("./leap.js");
var meta = require("./meta.js");
var util = require("./util.js");
var _core = require("@babel/core");
const PENDING_LOCATION = Number.MAX_VALUE;
function getDeclError(node) {
  return new Error("all declarations should have been transformed into " + "assignments before the Exploder began its work: " + JSON.stringify(node));
}
const catchParamVisitor = {
  Identifier: function (path, state) {
    if (path.node.name === state.catchParamName && util.isReference(path)) {
      path.replaceWith(state.getSafeParam());
    }
  },
  Scope: function (path, state) {
    if (path.scope.hasOwnBinding(state.catchParamName)) {
      path.skip();
    }
  }
};
class Emitter {
  constructor(contextId, scope, vars, pluginPass) {
    this.nextTempId = void 0;
    this.contextId = void 0;
    this.index = void 0;
    this.indexMap = void 0;
    this.listing = void 0;
    this.returns = void 0;
    this.lastReferenceIndex = 0;
    this.marked = void 0;
    this.insertedLocs = void 0;
    this.finalLoc = void 0;
    this.tryEntries = void 0;
    this.leapManager = void 0;
    this.scope = void 0;
    this.vars = void 0;
    this.pluginPass = void 0;
    this.pluginPass = pluginPass;
    this.scope = scope;
    this.vars = vars;
    this.nextTempId = 0;
    this.contextId = contextId;
    this.listing = [];
    this.index = 0;
    this.indexMap = new Map([[0, 0]]);
    this.returns = new Set();
    this.lastReferenceIndex = 0;
    this.marked = [true];
    this.insertedLocs = new Set();
    this.finalLoc = this.loc();
    this.tryEntries = [];
    this.leapManager = new leap.LeapManager(this);
  }
  loc() {
    const l = _core.types.numericLiteral(PENDING_LOCATION);
    this.insertedLocs.add(l);
    return l;
  }
  getInsertedLocs() {
    return this.insertedLocs;
  }
  getContextId() {
    return _core.types.cloneNode(this.contextId);
  }
  getIndex() {
    if (!this.indexMap.has(this.listing.length)) {
      this.indexMap.set(this.listing.length, ++this.index);
    }
    return this.index;
  }
  mark(loc) {
    if (loc.value === PENDING_LOCATION) {
      loc.value = this.getIndex();
    } else {
      _assert.strictEqual(loc.value, this.index);
    }
    this.marked[this.listing.length] = true;
    if (loc.value > this.lastReferenceIndex) {
      this.lastReferenceIndex = loc.value;
    }
    return loc;
  }
  emit(node) {
    if (_core.types.isExpression(node)) {
      node = _core.types.expressionStatement(node);
    }
    _core.types.assertStatement(node);
    this.listing.push(node);
  }
  emitAssign(lhs, rhs) {
    this.emit(this.assign(lhs, rhs));
    return lhs;
  }
  assign(lhs, rhs) {
    return _core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.cloneNode(lhs), rhs));
  }
  contextProperty(name) {
    const computed = name === "catch";
    return _core.types.memberExpression(this.getContextId(), computed ? _core.types.stringLiteral(name) : _core.types.identifier(name), !!computed);
  }
  clearPendingException(tryLoc, assignee) {
    const catchCall = _core.types.callExpression(this.contextProperty("catch"), [_core.types.cloneNode(tryLoc)]);
    if (assignee) {
      this.emitAssign(assignee, catchCall);
    } else {
      this.emit(catchCall);
    }
  }
  jump(toLoc) {
    this.emitAssign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "n" : "next"), toLoc);
    this.emit(_core.types.breakStatement());
  }
  jumpIf(test, toLoc) {
    this.emit(_core.types.ifStatement(test, _core.types.blockStatement([this.assign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "n" : "next"), toLoc), _core.types.breakStatement()])));
  }
  jumpIfNot(test, toLoc) {
    let negatedTest;
    if (_core.types.isUnaryExpression(test) && test.operator === "!") {
      negatedTest = test.argument;
    } else {
      negatedTest = _core.types.unaryExpression("!", test);
    }
    this.emit(_core.types.ifStatement(negatedTest, _core.types.blockStatement([this.assign(this.contextProperty(util.newHelpersAvailable(this.pluginPass) ? "n" : "next"), toLoc), _core.types.breakStatement()])));
  }
  makeContextTempVar() {
    return this.contextProperty("t" + this.nextTempId++);
  }
  makeTempVar() {
    const id = this.scope.generateUidIdentifier("t");
    this.vars.push(_core.types.variableDeclarator(id));
    return _core.types.cloneNode(id);
  }
  getContextFunction() {
    return _core.types.functionExpression(null, [this.getContextId()], _core.types.blockStatement([this.getDispatchLoop()]), false, false);
  }
  getDispatchLoop() {
    const self = this;
    const cases = [];
    let current;
    let alreadyEnded = false;
    self.listing.forEach(function (stmt, i) {
      if (self.marked[i]) {
        cases.push(_core.types.switchCase(_core.types.numericLiteral(self.indexMap.get(i)), current = []));
        alreadyEnded = false;
      }
      if (!alreadyEnded) {
        current.push(stmt);
        if (_core.types.isCompletionStatement(stmt)) alreadyEnded = true;
      }
    });
    this.finalLoc.value = this.getIndex();
    if (util.newHelpersAvailable(this.pluginPass)) {
      if (this.lastReferenceIndex === this.index || !this.returns.has(this.listing.length)) {
        cases.push(_core.types.switchCase(this.finalLoc, [_core.types.returnStatement(_core.types.callExpression(this.contextProperty("a"), [_core.types.numericLiteral(2)]))]));
      }
    } else {
      cases.push(_core.types.switchCase(this.finalLoc, []), _core.types.switchCase(_core.types.stringLiteral("end"), [_core.types.returnStatement(_core.types.callExpression(this.contextProperty("stop"), []))]));
    }
    return _core.types.whileStatement(_core.types.numericLiteral(1), _core.types.switchStatement(util.newHelpersAvailable(this.pluginPass) ? this.tryEntries.length === 0 ? this.contextProperty("n") : _core.types.assignmentExpression("=", this.contextProperty("p"), this.contextProperty("n")) : _core.types.assignmentExpression("=", this.contextProperty("prev"), this.contextProperty("next")), cases));
  }
  getTryLocsList() {
    if (this.tryEntries.length === 0) {
      return null;
    }
    let lastLocValue = 0;
    const arrayExpression = _core.types.arrayExpression(this.tryEntries.map(function (tryEntry) {
      const thisLocValue = tryEntry.firstLoc.value;
      _assert.ok(thisLocValue >= lastLocValue, "try entries out of order");
      lastLocValue = thisLocValue;
      const ce = tryEntry.catchEntry;
      const fe = tryEntry.finallyEntry;
      const locs = [tryEnt